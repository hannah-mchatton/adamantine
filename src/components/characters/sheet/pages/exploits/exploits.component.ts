import { Component, Input, OnInit } from '@angular/core';
import { Store } from '@ngrx/store';
import { Update } from 'src/components/pages/features/builder.actions';
import { selectUpdate } from 'src/components/pages/features/builder.selectors';
import { CharacterSheetService } from 'src/services/character-sheet.service';
import { DataService } from 'src/services/data.service';

@Component({
  selector: 'cs-exploits',
  templateUrl: './exploits.component.html',
  styleUrls: ['./exploits.component.scss'],
})
export class ExploitsComponent implements OnInit {
  @Input() character: any;
  @Input() characterExploits: any[];

  public modalVisible;
  public modalOption;

  public dice;
  public dieSize;
  public currDice;

  constructor(
    private characterSheetService: CharacterSheetService,
    private dataService: DataService,
    private store: Store
  ) {}

  public ngOnInit(): void {
    this.store.select(selectUpdate).subscribe((update) => {
      if (update) {
        let exploitLevel = 0;
        for (let c of this.character.classes) {
          const classData = this.dataService.getClass(c.name);
          if (classData?.exploits) {
            exploitLevel += Math.max(
              Math.floor(c.level / classData.exploitLevel),
              1
            );
          }

          if (c.subclass) {
            const subclassData = this.dataService.getSubclass(
              c.name,
              c.subclass
            );
            if (subclassData?.exploits) {
              exploitLevel += Math.max(
                Math.floor(c.level / subclassData.exploitLevel),
                1
              );
            }
          }
        }

        this.dice =
          this.characterSheetService.exploitDice[exploitLevel - 1] ?? 0;
        this.dieSize =
          this.characterSheetService.exploitDieSize[exploitLevel - 1] ?? 0;
        if (this.dice) {
          const useIndex = this.character.uses.findIndex(
            (u) => u.id === `exploits`
          );
          if (useIndex !== -1) {
            this.character.uses[useIndex].maxUses = this.dice;
            const currUses = this.character.uses[useIndex].currUses;
            if (this.currDice !== currUses) {
              this.currDice = currUses;
            }
          } else {
            this.character.uses.push({
              id: `exploits`,
              maxUses: this.dice,
              currUses: this.dice,
              reset: 1,
            });
            if (this.currDice === undefined) {
              this.currDice = this.dice;
            }
          }
        }

        const dieSizeUp = this.characterSheetService.dieSizeUp();
        if (
          this.character.classes.find(
            (c) => c.name.toLowerCase() === 'warlord'
          ) ||
          dieSizeUp
        ) {
          this.dieSize += 2;
        }
      }
    });
  }

  public openModal(spellName: string) {
    this.modalVisible = true;
    this.modalOption = spellName;
  }

  public characterLevel() {
    if (this.character?.classes) {
      return this.character.classes.reduce(
        (partialSum, a) => partialSum + a.level,
        0
      );
    }
    return 0;
  }
  public proficiencyBonus() {
    return Math.floor(2 + (this.characterLevel() - 1) / 4);
  }

  public getExploitDC(ability: string): number {
    const abilityMod = parseInt(this.getModifier(ability).toString());
    const prof = this.proficiencyBonus();

    return 8 + abilityMod + prof;
  }

  public getScore(score: string): number {
    return (this.character.scores?.actual ?? {})[score];
  }
  public getModifier(score: string): number {
    return this.modifier(this.getScore(score));
  }

  public modifier(score: number): number {
    let mod = -5;
    if (score) {
      mod = Math.floor((score - 10) / 2);
    }
    return mod;
  }

  public formatModifier(modifier: number): string {
    if (modifier !== undefined) {
      if (modifier > 0) {
        return `+${modifier}`;
      } else {
        return modifier.toString();
      }
    }
    return '';
  }

  public updateDice() {
    if (this.character.uses) {
      let useIndex = this.character.uses.findIndex((u) => u.id === `exploits`);

      if (useIndex !== -1) {
        this.character.uses[useIndex].currUses = this.currDice;
      }
    }

    this.store.dispatch(new Update());
  }
  public changeDice(direction) {
    if (this.character.uses) {
      let useIndex = this.character.uses.findIndex((u) => u.id === `exploits`);

      if (useIndex !== -1) {
        this.character.uses[useIndex].currUses += direction;
        this.currDice = this.character.uses[useIndex].currUses;
      }
    }

    this.store.dispatch(new Update());
  }
}
